# -*- coding: utf-8 -*-
"""hw4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q7Ybz_GTvMdjiVzuZp33IvmVcq--jW4_
"""

import math
# 1.
# Написать функцию, вычисляющее значение функции при х = 1.79

def solve(x: float) -> float:
    return (math.cos(math.e ** x) + math.log((1 + x) ** 2) + math.sqrt(
        math.e ** math.cos(x) + math.sin(math.pi * x) ** 2) + math.sqrt(1 / x) +
            math.cos(x ** 2)) ** math.sin(x)

print(solve(1.79))

# 2.
# Напишите функцию search_substr(subst, st), которая принимает 2 строки и
# определяет, имеется ли подстрока subst в строке st. В случае нахождения
# подстроки, возвращается фраза «Есть контакт!», а иначе «Мимо!». Должно
# быть найдено совпадение независимо от регистра обеих строк.


def search_substr(subst: str, st: str) -> str:
    if not type(subst) is str or not type(st) is str:
        # Check for type
        return "Оба параметра должны быть строкой"
    if not subst:
        # We do not want to check against an empty substring
        return "В подстроке должен быть хотя бы один символ"
    return "Есть контакт!" if subst.lower() in st.lower() else "Мимо!"


print(search_substr("тАКт", "Есть контакт!"))  # prints "Есть контакт!"
print(search_substr("мимо", "Есть контакт!"))  # prints "Мимо!"
print(search_substr("", "Есть контакт!"))  # prints "В подстроке должен быть хотя бы один символ"
print(search_substr(4, "Есть конт4кт!"))  # prints "Оба параметра должны быть строкой"

from collections import Counter
# 3.
# На основании строки определить 3 наиболее часто встречаемых символа в
# ней. Пробелы нужно игнорировать (не учитывать при подсчете). Для простоты
# подсчета количества вхождений символов удобно использовать Counter из
# модуля collections.
# Давайте договоримся вернуть топ 3, если есть повторяющиеся, то их все вернуть


# Function returns most common symbols if there is tie, return all symbols of that length
def get_most_common_symbols(input_string: str, amount: int = 3) -> list:
    if amount < 1:
        return []
    # Remove spaces, tabs and new lines, they should not be mapped
    formatted_input = ''.join(input_string.split())

    # Get most common symbols
    c = Counter(formatted_input)
    most_common = c.most_common(amount)

    # Check for elements with same frequency
    if len(most_common) == amount:
        # Get the least frequent elements with top frequency
        to_check_frequency = most_common[-1][1]
        # Get all other characters which have the same frequency, but exclude the ones already in most_common
        same_length_chars = [(char, count) for char, count in c.items() if
                             count == to_check_frequency and (char, count) not in most_common]
        most_common.extend(same_length_chars)

    return most_common


print(get_most_common_symbols("aaaabbbcco[km]"))
print(get_most_common_symbols("""     d        d   sdfl v 1"""))

# 4.
# Дана строка в виде случайной последовательности чисел от 0 до 9. Требуется
# создать словарь, который в качестве ключей будет принимать данные числа (т.
# е. ключи будут типом int), а в качестве значений – количество этих чисел в
# имеющейся последовательности. Для построения словаря создайте функцию
# count_it(sequence), принимающую строку из цифр. Функция должна
# возвратить словарь из 3-х самых часто встречаемых чисел.


# Method for input check
def is_numeric_string(input_str):
    try:
        int(input_str)
        return True
    except ValueError:
        return False


# NB! Relies on above cell to be executed.
def get_most_common_symbols_dict(input_string: str) -> dict:
    if not is_numeric_string(input_string):
        raise ValueError(f"String '{input_string}' does not consist only of digits")
    # DRY
    return {int(key): value for key, value in get_most_common_symbols(input_string, 3)}


# Do not forget to execute the above cell before running this cell!
print(get_most_common_symbols_dict("000002121860"))
try:
    print(get_most_common_symbols_dict("1223a"))
except ValueError as e:
    print(e)

